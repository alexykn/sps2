//! Python isolation patcher - creates wrapper scripts for isolated Python packages

use crate::artifact_qa::{
    reports::Report,
    traits::{Action, Patcher},
};
use crate::{BuildContext, BuildEnvironment};
use sps2_errors::{BuildError, Error};
use std::collections::HashMap;
use std::os::unix::fs::PermissionsExt;
use std::path::Path;
use tokio::fs;

#[derive(Default)]
pub struct PythonIsolationPatcher;

impl PythonIsolationPatcher {
    /// Detect Python version from package-specific lib directory
    async fn detect_python_version(&self, package_prefix: &Path) -> Result<String, Error> {
        let lib_dir = package_prefix.join("lib");
        if !lib_dir.exists() {
            return Err(BuildError::InstallFailed {
                message: "No lib directory found in package prefix".to_string(),
            }
            .into());
        }

        let mut entries = fs::read_dir(&lib_dir).await?;
        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if path.is_dir() {
                let dir_name = path.file_name().unwrap().to_string_lossy();
                if dir_name.starts_with("python3.") {
                    // Extract version from directory name like "python3.11"
                    return Ok(dir_name.to_string());
                }
            }
        }

        Err(BuildError::InstallFailed {
            message: "Could not detect Python version from package lib directory".to_string(),
        }
        .into())
    }

    /// Find all executables in package bin directory
    async fn find_package_executables(&self, package_bin_dir: &Path) -> Result<Vec<String>, Error> {
        let mut executables = Vec::new();

        if !package_bin_dir.exists() {
            return Ok(executables);
        }

        let mut entries = fs::read_dir(package_bin_dir).await?;
        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if path.is_file() {
                if let Some(filename) = path.file_name().and_then(|n| n.to_str()) {
                    // Check if file is executable
                    if let Ok(metadata) = path.metadata() {
                        let permissions = metadata.permissions();
                        if permissions.mode() & 0o111 != 0 {
                            // File is executable
                            executables.push(filename.to_string());
                        }
                    }
                }
            }
        }

        Ok(executables)
    }

    /// Create wrapper script for a Python executable
    async fn create_wrapper_script(
        &self,
        main_bin_dir: &Path,
        executable_name: &str,
        package_name: &str,
        python_version: &str,
    ) -> Result<(), Error> {
        let wrapper_path = main_bin_dir.join(executable_name);

        // Create wrapper script content
        let wrapper_content = format!(
            r#"#!/bin/bash
# Wrapper for {executable_name} from {package_name} package
# Generated by sps2 Python isolation patcher

export PYTHONPATH="{live}/python/{package_name}/lib/{python_version}/site-packages:${{PYTHONPATH}}"
exec {live}/bin/{python_version} "{live}/python/{package_name}/bin/{executable_name}" "$@"
"#,
            live = sps2_config::fixed_paths::LIVE_DIR
        );

        // Write wrapper script
        fs::write(&wrapper_path, wrapper_content).await?;

        // Make wrapper script executable
        let mut permissions = fs::metadata(&wrapper_path).await?.permissions();
        permissions.set_mode(0o755);
        fs::set_permissions(&wrapper_path, permissions).await?;

        Ok(())
    }
}

impl Action for PythonIsolationPatcher {
    const NAME: &'static str = "Python Isolation";

    async fn run(
        _ctx: &BuildContext,
        env: &BuildEnvironment,
        _findings: Option<&crate::artifact_qa::diagnostics::DiagnosticCollector>,
    ) -> Result<Report, Error> {
        let self_instance = Self;

        // Only run for Python packages
        if !env.is_python_package() {
            return Ok(Report::ok());
        }

        let staging_dir = env.staging_dir();
        let live_prefix = env.get_live_prefix().trim_start_matches('/');
        let package_name = env.package_name();

        // Check if we have entry points from build metadata
        let entry_points_json = env
            .get_extra_env("PYTHON_ENTRY_POINTS")
            .unwrap_or_else(|| "{}".to_string());

        let entry_points: HashMap<String, String> =
            serde_json::from_str(&entry_points_json).unwrap_or_default();

        if entry_points.is_empty() {
            return Ok(Report::ok());
        }

        let package_specific_prefix = staging_dir
            .join(live_prefix)
            .join("python")
            .join(package_name);

        // Detect Python version from package lib directory
        let python_version = self_instance
            .detect_python_version(&package_specific_prefix)
            .await?;

        // Find all executables in package bin directory
        let package_bin_dir = package_specific_prefix.join("bin");
        let executables = self_instance
            .find_package_executables(&package_bin_dir)
            .await?;

        if executables.is_empty() {
            return Ok(Report::ok());
        }

        // Create main bin directory if it doesn't exist
        let main_bin_dir = staging_dir.join(live_prefix).join("bin");
        fs::create_dir_all(&main_bin_dir).await?;

        // Create wrapper scripts for all executables
        let mut created_wrappers = Vec::new();
        for executable in &executables {
            self_instance
                .create_wrapper_script(&main_bin_dir, executable, package_name, &python_version)
                .await?;
            created_wrappers.push(main_bin_dir.join(executable));
        }

        Ok(Report {
            changed_files: created_wrappers,
            ..Default::default()
        })
    }
}

impl Patcher for PythonIsolationPatcher {}
